<html>
<head>
    <title>Draw</title>
    <style>
    * {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        color: white;
    }
    #canvas {
        position: absolute;
        margin-bottom: 5%;
    }
    #toolbar {
        height: 5%;
        background-color: #202020;
        position: absolute;
        width: 100%;
        bottom: 0;
    }
    #controls {
        display: flex;
        flex-direction: row;
        position: absolute;
        margin: 0;
        left: 5%;
        top: 50%;
        height: 80%;
        -ms-transform: translateY(-50%);
        transform: translateY(-50%);
    }
    button {
        color: black;
        min-width: 50px;
    }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="toolbar">
        <div id="controls">
            <button onclick=undo()><==</button>&nbsp;&nbsp;
            <button onclick=redo()>==></button>
        </div>
    </div>
    <script>
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        let pX = null;
        let pY = null;
        let isDrawing = false;
        let history = [];
        let stroke = [];
        let history_length = 0;

        function init() {
            canvas.height = window.innerHeight;
            canvas.width = window.innerWidth;
            ctx.lineWidth = 5;
        }
        function draw_stroke(startX, startY, endX, endY) {
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }
        function start_stoke(newX, newY) {
            isDrawing = true;
            history.length = history_length;
            pX = newX;
            pY = newY;
            stroke.push([pX, pY]);
        }
        function stop_stoke() {
            isDrawing = false;
            history.push(stroke);
            history_length++;
            stroke = [];
        }
        function move_stroke(newX, newY) {
            if (!isDrawing) {
                return;
            }
            ctx.beginPath();
            draw_stroke(pX, pY, newX, newY);
            pX = newX;
            pY = newY;
            stroke.push([pX, pY]);
        }
        function redraw(num_strokes) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            for (let i = 0; i < num_strokes; i++) {
                for (let j = 1; j < history[i].length; j++) {
                    draw_stroke(history[i][j-1][0], history[i][j-1][1], history[i][j][0], history[i][j][1]);
                }
            }
        }
        function undo() {
            if (history_length == 0){
                return;
            }
            redraw(history_length-1);
            history_length--;
        }
        function redo() {
            if (history.length == history_length){
                return;
            }
            redraw(history_length+1);
            history_length++;
        }

        window.addEventListener("load", () => {init()});
        canvas.addEventListener("mousedown", (e) => {start_stoke(e.clientX, e.clientY)});
        canvas.addEventListener("mouseup", () => {stop_stoke()});
        canvas.addEventListener("mousemove", (e) => {move_stroke(e.clientX, e.clientY)});
        canvas.addEventListener("touchstart", (e) => {start_stoke(e.touches[0].clientX, e.touches[0].clientY)});
        canvas.addEventListener("touchend", () => {stop_stoke()});
        canvas.addEventListener("touchmove", (e) => {move_stroke(e.touches[0].clientX, e.touches[0].clientY)});
        window.addEventListener("keydown", (e) => {
            if (e.ctrlKey && e.key === 'z'){
                undo();
            } else if (e.ctrlKey && e.key === 'r'){
                redo();
            }
        });
    </script>
</body>
</html>
